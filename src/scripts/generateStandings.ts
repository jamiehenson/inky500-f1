import fs from 'fs'
import { JSDOM } from 'jsdom'
import resultsData from '../data/results'
import seasonRacersData from '../data/seasonRacers'
import trackData from '../data/tracks.json'
import driversData from '../data/drivers.json'
import penaltiesData from '../data/penalties'
import {
  type RacerResults,
  type TrackName,
  type SeasonName,
  type Tracks,
  type SeasonRacers,
  type RacerName,
  type ConstructorResult,
  type Penalties
} from '../types'
import { pointsScheme, pointslessResults } from '../utils'

type GeneratedConstructorStandings = {
  [index: string]: ConstructorResult
}

type GeneratedRaceStandings = {
  [index: string]: number
}

type GeneratedStandings = {
  [index: string]: GeneratedRaceStandings | GeneratedConstructorStandings | null
}

const standardDriverCount = 2
const autoGeneratedSeasons = ['s4']

const timeGrabber = async (season: string, race: string, link: string) => {
  const response = await fetch(link)
  const html = await response.text()
  const dom = new JSDOM(
    html
      .replace(/<style([\S\s]*?)>([\S\s]*?)<\/style>/gim, '')
      .replace(/<script([\S\s]*?)>([\S\s]*?)<\/script>/gim, '')
  )

  const table = dom.window.document.querySelector('table')

  const results: Record<string, string> = {}
  const fastestLap = {
    racerId: 'unknown',
    time: '23:59:999'
  }
  let highestLapCount = 0

  if (table) {
    const times = Array.from(table.querySelectorAll('tr'))
      .map((row) => {
        const cells = row.querySelectorAll('td')
        const driver = cells[1]
        const totalTime = cells[3]
        const numLaps = cells[4]
        const bestLap = cells[5]

        if (driver && totalTime && bestLap && numLaps) {
          return [
            driver.innerHTML.split('\n')[0],
            totalTime.innerHTML,
            bestLap.innerHTML.split('<')[0],
            numLaps.innerHTML.split('lap')[0]
          ]
        }

        return []
      })
      .slice(1)

    let lapCounter = 0

    times.forEach((time, index) => {
      const tableName = time[0]
      const name =
        Object.entries(driversData).find((driver) =>
          (driver[1] as { tableNames: string[] }).tableNames?.includes(tableName)
        )?.[0] ?? tableName

      let parsedTime = time[1].split(':').slice(1).join(':')

      if (Number(time[3]) > highestLapCount) {
        highestLapCount = Number(time[3])
      } else if (Number(time[3]) <= highestLapCount - 5) {
        parsedTime = 'DNF'
      } else {
        if (index > 0) {
          parsedTime = (
            (Date.parse(`01/01/2000 ${time[1]}`) -
              Date.parse(`01/01/2000 ${times[index - 1][1]}`)) /
            1000
          )
            .toFixed(3)
            .toString()
        }

        if (parsedTime.startsWith('-')) {
          lapCounter++
          parsedTime = `${lapCounter} lap${lapCounter === 1 ? '' : 's'}`
        } else if (lapCounter > 0) {
          parsedTime = `${lapCounter} lap${lapCounter === 1 ? '' : 's'}`
        }
      }

      results[name] = parsedTime

      if (
        time[2] !== '00:00.000' &&
        Date.parse(`01/01/2000 00:${time[2]}`) < Date.parse(`01/01/2000 00:${fastestLap.time}`)
      ) {
        fastestLap.time = time[2]
        fastestLap.racerId = name
      }
    })
  }

  // Perform any penalty rearrangements
  const resultsKeys = Object.keys(results)
  const copy = [...resultsKeys]
  copy.forEach((result, index) => {
    const penalty = (penaltiesData[season as SeasonName] as Penalties)?.[race]?.[result]

    if (penalty) {
      resultsKeys.splice(index, 1)
      resultsKeys.splice(index + penalty, 0, result)
    }
  })

  const orderedResults = resultsKeys.reduce((obj: Record<string, string>, item: string) => {
    return (obj[item] = results[item]), obj
  }, {})

  return { results: orderedResults, fastestLap, data: link }
}

const calculateStandings = (season: SeasonName) => {
  const seasonRaces = Object.keys(resultsData[season])
  const constructorPoints: Record<
    string,
    Record<string, { points: number; normalisedPoints: number; driverCount: number }>
  > = {}

  // Compile initial race scores into standings objects
  const points = seasonRaces.reduce((racesObj: GeneratedStandings, race: string) => {
    const raceResults = (resultsData[season] as RacerResults)[race as TrackName]
    const noPointsRace = (trackData as Tracks)[race as TrackName].noPoints

    const pts = raceResults
      ? Object.entries(raceResults.results).reduce(
          (obj: GeneratedRaceStandings, item: [string, string], currentIndex) => {
            const dnf = pointslessResults.includes(item[1])
            const cumulativePoints =
              (pointsScheme[season][currentIndex] ?? 0) +
              (raceResults.fastestLap.racerId === item[0] ? 1 : 0)

            return (obj[item[0]] = noPointsRace || dnf ? 0 : cumulativePoints), obj
          },
          {}
        )
      : null

    return (racesObj[race] = pts), racesObj
  }, {})

  // Add the points for each driver and team cumulatively, and reorder
  const raceKeys = Object.keys(points)

  raceKeys.forEach((race, index) => {
    if (points[race] === null) {
      return
    }

    const racePoints = points[race] as GeneratedRaceStandings
    const previousRacePoints = points[raceKeys[index - 1]] as GeneratedRaceStandings
    const racePointsKeys = Object.keys(racePoints)
    racePointsKeys.forEach((driver) => {
      const seasonRacer = (seasonRacersData[season as SeasonName] as SeasonRacers)[
        driver as RacerName
      ]
      const car = seasonRacer.otherCars?.[race] ?? seasonRacer.car

      constructorPoints[race] = {
        ...constructorPoints[race],
        [car]: {
          points: (constructorPoints[race]?.[car]?.points ?? 0) + racePoints[driver],
          normalisedPoints: (constructorPoints[race]?.[car]?.points ?? 0) + racePoints[driver],
          driverCount: (constructorPoints[race]?.[car]?.driverCount ?? 0) + 1
        }
      }

      if (index > 0) {
        racePoints[driver] += previousRacePoints[driver] ?? 0
      }
    })

    // Fill in other drivers in the standings who didn't compete in a given race
    if (index > 0) {
      Object.keys(seasonRacersData[season]).forEach((driver) => {
        if (!racePointsKeys.includes(driver)) {
          racePoints[driver] = previousRacePoints[driver]
        }
      })
    }

    if (constructorPoints[race]) {
      Object.entries(constructorPoints[race]).map((constructor) => {
        constructorPoints[race][constructor[0]].normalisedPoints = Math.round(
          constructor[1].points * (standardDriverCount / constructor[1].driverCount)
        )
      })

      const cumulativePoints = Object.entries(constructorPoints[race]).map((raceConstructors) => {
        if (index > 0) {
          raceConstructors[1].points +=
            constructorPoints[raceKeys[index - 1]][raceConstructors[0]].points
          raceConstructors[1].normalisedPoints +=
            constructorPoints[raceKeys[index - 1]][raceConstructors[0]].normalisedPoints
        }

        return raceConstructors
      })

      if (index > 0) {
        const missed = Object.keys(constructorPoints[raceKeys[index - 1]]).filter(
          (constructor) => !cumulativePoints.map((a) => a[0]).includes(constructor)
        )

        if (missed.length > 0) {
          missed.forEach((constructor) => {
            cumulativePoints.push([
              constructor,
              constructorPoints[raceKeys[index - 1]][constructor]
            ])
          })
        }
      }

      constructorPoints[race] = cumulativePoints
        .sort(([, a], [, b]) => b.normalisedPoints - a.normalisedPoints)
        .reduce((r, [k, v]) => ({ ...r, [k]: v }), {})
    }

    points[race] = Object.entries(racePoints)
      .sort(([, a], [, b]) => b - a)
      .reduce((r, [k, v]) => ({ ...r, [k]: v }), {})
  })

  return [points, constructorPoints]
}

const generateStandings = () => {
  autoGeneratedSeasons.forEach(async (season) => {
    if (process.argv[2] === 'add') {
      const parsedResults = await timeGrabber(process.argv[3], process.argv[4], process.argv[5])

      const resultsPath = `src/data/results/${process.argv[3]}.json`
      const resultsFile = JSON.parse(fs.readFileSync(resultsPath, 'utf8'))

      resultsFile[process.argv[4]] = parsedResults

      fs.writeFileSync(resultsPath, JSON.stringify(resultsFile), { flag: 'w' })
    }

    const standingsResults = calculateStandings(season as SeasonName)

    const standings = JSON.stringify(standingsResults[0])
    const standingsPath = `src/data/standings/${season}.json`

    try {
      fs.writeFileSync(standingsPath, standings, { flag: 'w' })
      console.log(`${season} standings data saved to file successfully.`)
    } catch (error) {
      console.error('Error writing JSON data to file:', error)
    }

    const constructors = JSON.stringify(standingsResults[1])
    const constructorsPath = `src/data/constructors/${season}.json`

    try {
      fs.writeFileSync(constructorsPath, constructors, { flag: 'w' })
      console.log(`${season} constructors data saved to file successfully.`)
    } catch (error) {
      console.error('Error writing JSON data to file:', error)
    }
  })
}

if (process) {
  generateStandings()
}
